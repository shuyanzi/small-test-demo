<!DOCTYPE html>
<html>
<head>
  <title>Camera Stream with Duplicate Frame Detection</title>
  <style>
    #status {
      font-weight: bold;
      font-size: 1.2em;
    }
    video {
      width: 600px;
    }
    canvas, img {
      width:80vw;
    }
  </style>
</head>
<body>
  <video id="video" autoplay></video>
  <div id="status">Loading...</div>
  <!--
    现象：
    1、分辨率1920*1080时
    生成canvas的图不压缩，真实摄像头和OBS都 检测不到 重复帧；
    图片压缩成600*600，真实摄像头 检测不到，OBS检测重复帧且重复帧是上一帧
    2、分辨率是600时（生成canvas的图不压缩）
    真实摄像头 检测不到
    OBS检测重复帧且重复帧是上一帧
  -->

  <script>
    const video = document.getElementById('video');
    const status = document.getElementById('status');

    // SHA-256 hash function
    function sha256(data) {
      const msgUint8 = new TextEncoder().encode(data);
      return crypto.subtle.digest('SHA-256', msgUint8).then(hashBuffer => {
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
      });
    }
    function sha256Buffer(buffer) {
      console.log("%c Line:34 🥛 buffer", "color:#93c0a4", buffer);
      return crypto.subtle.digest('SHA-256', buffer).then(hashBuffer => {
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
      });
    }

    function initSize(canvas, video) {
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0);
      return ctx
    }
    function cropSize(canvas, video) {
      const ctx = canvas.getContext('2d');
      canvas.width = 400
      canvas.height = 400
      ctx.drawImage(video, 
        420,0,
        1080,1080,
        0,0,
        400,400
      )
      return ctx
    }
    function cropInitRateSize(canvas, video) {
      const ctx = canvas.getContext('2d');
      canvas.width = 1080
      canvas.height = 1080
      ctx.drawImage(video, 
        420,0,
        1080,1080,
        0,0,
        1080,1080
      )
      return ctx
    }

    navigator.mediaDevices.enumerateDevices()
      .then(devices => {
        const videoSources = devices.filter(device => device.kind === 'videoinput');
        const options = videoSources.map(source => `<option value="${source.deviceId}">${source.label}</option>`);

        const select = `<select id="videoSource">${options.join('')}</select>`;
        document.body.insertAdjacentHTML('beforeend', select);

        const videoSource = document.getElementById('videoSource');
        videoSource.addEventListener('change', () => {
          const selectedDeviceId = videoSource.value;
          const constraints = {
            video: {
              width: 1920,
              height: 1080,
              // width: {
              //   exact: 1600
              // },
              // height: {
              //   exact: 1200
              // },
              deviceId: selectedDeviceId
              // deviceId: 'fbdd8b5eb81a77b6f8e7bfae03fecaee99e3ae91cd2b1fa84a30244410d09b4f'
            }
          };
          console.log("%c Line:57 🥑 constraints", "color:#93c0a4", constraints);

          navigator.mediaDevices.getUserMedia(constraints)
            .then(stream => {
              video.srcObject = stream;

              const frames = new Map();
              let isDetected = false;
              let framesInfo = []
              let frameCount = -1
              const detectDuplicateFrames = async (now, metadata) => {
                frameCount++
                // if (isDetected) return;
                const canvas = document.createElement('canvas');
                const canvasCtx = cropSize(canvas,video)
                // const canvasCtx = initSize(canvas,video)


                const initCanvas = document.createElement('canvas');
                const initCanvasCtx = initSize(initCanvas,video)
                // cropInitRateSize(canvas,video)
                var start = new Date().getTime()
                const imageData = canvasCtx.getImageData(
                  0,
                  0,
                  canvas.width,
                  canvas.height
                )
                const initImageData = initCanvasCtx.getImageData(
                  0,
                  0,
                  initCanvas.width,
                  initCanvas.height
                )
                const currentFrameData = imageData.data;
                const hash = await sha256Buffer(currentFrameData);

                if (frames.has(hash)) {
                  console.log("%c Line:86 🥚 hash", "color:#ffdd4d", {hash, index: framesInfo.indexOf(hash), len: framesInfo.length,framesInfo});
                  // console.log("%c Line:69 🌮 hash", "color:#ed9ec7", frames,hash,currentFrame);
                  isDetected = true;
                  status.textContent = '检测到重复帧';
                  status.style.color = 'red';

                  for (const [frameHash, frameData] of frames) {
                    if (frameHash === hash) {
                      const canvas1 = document.createElement('canvas');
                      const ctx1 = canvas1.getContext('2d');
                      canvas.width = frameData.width;
                      canvas.height = frameData.height;
                      console.log("%c Line:155 🥛 frameData", "color:#ea7e5c", frameData);
                      ctx1.putImageData(frameData.data, 0, 0);
                      document.body.appendChild(canvas1);


                      // const img = new Image();
                      // img.src = frameData.currentFrameData;
                      // document.body.appendChild(img);
                      // const hashLast = await sha256(frameData.initImg);
                      // const img2 = new Image();
                      // img2.src = frameData.initImg;
                      // console.log("%c Line:167 🍪 new hashLast", "color:#33a5ff", {hashLast});
                      // document.body.appendChild(img2);
                      break;
                    }
                  }

                  console.log("%c Line:178 🍊 initImageData.data", "color:#6ec1c2", initImageData.data);
                  // const img = new Image();
                  // img.src = currentFrame;
                  // document.body.appendChild(img);

                  // const nowFull = initCanvas.toDataURL()
                  // const hashNow = await sha256(nowFull);
                  // const img2 = new Image();
                  // img2.src = nowFull;
                  // console.log("%c Line:167 🍪 new hashNow", "color:#33a5ff", {hashNow});
                  // document.body.appendChild(img2);
                  // img.onload = () => currCtx.drawImage(img, 0, 0);
                } else {
                  status.textContent = '没检测到重复帧';
                  status.style.color = 'green';
                  frames.set(hash, { data: imageData, width: canvas.width, height: canvas.height, initImageData: initImageData.data });
                  // frames.set(hash, {currentFrame, initImg: initCanvas.toDataURL()});
                  var end = new Date().getTime()
                  console.log('cost is', `${end - start}ms`)
                  video.requestVideoFrameCallback(detectDuplicateFrames);
                }
                framesInfo.push(hash)
              };

              video.requestVideoFrameCallback(detectDuplicateFrames);
            })
            .catch(err => console.error('Error accessing camera:', err));
        });

        videoSource.value = videoSources[0].deviceId;
        videoSource.dispatchEvent(new Event('change'));
      })
      .catch(err => console.error('Error enumerating devices:', err));
  </script>
</body>
</html>